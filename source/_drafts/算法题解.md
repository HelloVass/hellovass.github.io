---
title: 算法题解
tags:
- leetcode
- 算法题解
---

##[206 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

### 思路一

双指针迭代法

申请两个指针，prev 和 cur。prev 最初指向 null，cur 指向 head 节点，然后 cur 不断遍历链表。每次迭代 cur，先将

cur 的 next 指向 prev，然后 prev 前进一步，cur 前进一步：

```kotlin
prev = null
cur = head
while(cur != null){
	val next = cur.next
	cur.next = prev
	prev = cur
	cur = next
}
```

如图：

![图解](https://hellovass-blog-1257365569.cos.ap-shanghai.myqcloud.com/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC.gif)

注意，要让 cur 也前进一步，需要事先用一个 next 变量来保存 cur 的一下个节点，也就是对应代码：`val next = cur.next`。

### 洁癖

通过 kotlin 的扩展函数特性，我们可以这么玩，给 ListNode 加上一个 reverse 函数，like this：

```kotlin
	fun ListNode?.reverse(): ListNode? {

    if (this == null || next == null)
        return this

    var prev: ListNode? = null
    var cur: ListNode? = this

    while (cur != null) {
        val next = cur.next
        cur.next = prev
        prev = cur
        cur = next
    }

    return prev
}
```

this 指代**头节点**，当头结点为 null 或者只有一个节点时，直接返回头节点本身。

